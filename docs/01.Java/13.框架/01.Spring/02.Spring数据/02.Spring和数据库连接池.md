---
title: Spring 和数据库连接池
date: 2022-09-21 23:58:06
categories: 
  - Java
  - 框架
  - Spring
  - Spring数据
tags: 
  - Java
  - 框架
  - Spring
  - SpringBoot
  - 数据库
  - DataSource
  - 数据库连接池
permalink: /pages/be5227/
---

# Spring 和数据库连接池

> 数据库连接池负责分配、管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个；释放空闲时间超过最大空闲时间的数据库连接来避免因为没有释放数据库连接而引起的数据库连接遗漏。这项技术能明显提高对数据库操作的性能。——摘自百度百科

## 什么是数据库连接池

数据库连接是一种关键的有限的昂贵的资源，这一点在多用户的网页应用程序中体现得尤为突出。 一个数据库连接对象均对应一个物理数据库连接，每次操作都打开一个物理连接，使用完都关闭连接，这样造成系统的 性能低下。 数据库连接池的解决方案是在应用程序启动时建立足够的数据库连接，并讲这些连接组成一个连接池(简单说：在一个“池”里放了好多半成品的数据库联接对象)，由应用程序动态地对池中的连接进行申请、使用和释放。对于多于连接池中连接数的并发请求，应该在请求队列中排队等待。并且应用程序可以根据池中连接的使用率，动态增加或减少池中的连接数。 连接池技术尽可能多地重用了消耗内存地资源，大大节省了内存，提高了服务器地服务效率，能够支持更多的客户服务。通过使用连接池，将大大提高程序运行效率，同时，我们可以通过其自身的管理机制来监视数据库连接的数量、使用情况等。

## 为什么需要数据库连接池

### 不使用数据库连接池

![](https://raw.githubusercontent.com/dunwu/images/dev/snap/20220921231353.png)

不使用数据库连接池的**步骤**：

1. TCP 建立连接的三次握手
2. MySQL 认证的三次握手
3. 真正的 SQL 执行
4. MySQL 的关闭
5. TCP 的四次握手关闭

不使用数据库连接池的特性：

- **优点**：实现简单
- **缺点**：
  - 网络 IO 较多
  - 数据库的负载较高
  - 响应时间较长及 QPS 较低
  - 应用频繁的创建连接和关闭连接，导致临时对象较多，GC 频繁
  - 在关闭连接后，会出现大量 TIME_WAIT 的 TCP 状态（在 2 个 MSL 之后关闭）

### 使用数据库连接池

![](https://raw.githubusercontent.com/dunwu/images/dev/snap/20220921231500.png)

使用数据库连接池的步骤：只有第一次访问的时候，需要建立连接。 但是之后的访问，均会**复用**之前创建的连接，直接执行 SQL 语句。

使用数据库连接池的**优点**：

- 减少了网络开销
- 系统的性能会有一个实质的提升
- 没有了 TIME_WAIT 状态

## 数据库连接池如何工作

数据库连接池工作的核心在于以下几点：

1. **创建连接池**：与线程池等池化对象类似，数据库连接池会在进程启动之初，根据配置初始化，并在池中创建了几个连接对象，以便使用时能从连接池中获取。连接池中的连接不能随意创建和关闭，以避免创建、关闭所带来的系统开销。
2. **使用、管理连接池中**：连接池管理策略是连接池机制的核心，连接池内连接的分配和释放对系统的性能有很大的影响。合理的策略可以保证数据库连接的有效复用，避免频繁的建立、释放连接所带来的系统资源开销。通常，数据库连接池的管理策略如下：

   1. 当请求数据库连接时，首先查看连接池中是否有空闲连接。
   2. 如果存在空闲连接，则将连接分配给客户使用。
   3. 如果没有空闲连接，则查看当前所开的连接数是否已经达到最大连接数。若未达到，就重新创建一个连接，并分配给请求的客户；如果达到，就按设定的最大等待时间进行等待，若超出最大等待时间，则抛出异常给客户。
   4. 当客户释放数据库连接时，先判断该连接的引用次数是否超过了规定值。如果超过，就从连接池中删除该连接；否则保留为其他客户服务。

3. **关闭连接池**：当应用程序退出时，关闭连接池中所有的连接，释放连接池相关的资源，该过程正好与创建相反。

## 数据库连接池的核心参数

使用数据库连接池，需要为其配置一些参数，以控制其工作。

通常，数据库连接池都会包含以下核心参数：

- **最小连接数**：是连接池一直保持的数据库连接,所以如果应用程序对数据库连接的使用量不大,将会有大量的数据库连接资源被浪费.
- **最大连接数**：是连接池能申请的最大连接数,如果数据库连接请求超过次数,后面的数据库连接请求将被加入到等待队列中,这会影响以后的数据库操作
- 最大空闲时间
- 获取连接超时时间
- 超时重试连接次数

## 数据库连接池的问题

**并发问题**：为了保证连接管理服务具有最大的通用性，必须考虑多线程环境，即并发问题。

**事务处理**：我们知道，事务具有原子性，此时要求对数据库的操作符合“ALL-OR-NOTHING”原则,即对于一组 SQL 语句要么全做，要么全不做。我们知道当 2 个线程共用一个连接 Connection 对象，而且各自都有自己的事务要处理时候，对于连接池是一个很头疼的问题，因为即使 Connection 类提供了相应的事务支持，可是我们仍然不能确定那个数据库操作是对应那个事务的，这是由于我们有２个线程都在进行事务操作而引起的。为此我们可以使用每一个事务独占一个连接来实现，虽然这种方法有点浪费连接池资源但是可以大大降低事务管理的复杂性。

**连接池的分配与释放**：连接池的分配与释放，对系统的性能有很大的影响。合理的分配与释放，可以提高连接的复用度，从而降低建立新连接的开销，同时还可以加快用户的访问速度。 对于连接的管理可使用一个 List。即把已经创建的连接都放入 List 中去统一管理。每当用户请求一个连接时，系统检查这个 List 中有没有可以分配的连接。如果有就把那个最合适的连接分配给他；如果没有就抛出一个异常给用户。

**连接池的配置与维护**：连接池中到底应该放置多少连接，才能使系统的性能最佳？系统可采取设置最小连接数（minConnection）和最大连接数（maxConnection）等参数来控制连接池中的连接。比方说，最小连接数是系统启动时连接池所创建的连接数。如果创建过多，则系统启动就慢，但创建后系统的响应速度会很快；如果创建过少，则系统启动的很快，响应起来却慢。这样，可以在开发时，设置较小的最小连接数，开发起来会快，而在系统实际使用时设置较大的，因为这样对访问客户来说速度会快些。最大连接数是连接池中允许连接的最大数目，具体设置多少，要看系统的访问量，可通过软件需求上得到。 如何确保连接池中的最小连接数呢？有动态和静态两种策略。动态即每隔一定时间就对连接池进行检测，如果发现连接数量小于最小连接数，则补充相应数量的新连接,以保证连接池的正常运转。静态是发现空闲连接不够时再去检查。

## Spring Boot 对于数据库连接池的支持

Spring Boot 支持多种数据库连接方式，如：

- HikariCP
- Tomcat pooling `Datasource`
- Commons DBCP2
- Oracle UCP & `OracleDataSource`
- Spring Framework’s `SimpleDriverDataSource`
- H2 `JdbcDataSource`
- PostgreSQL `PGSimpleDataSource`
- C3P0

配置数据库连接池，可以通过如 `spring.datasource.hikari.*`、`spring.datasource.tomcat.*`、`spring.datasource.dbcp2.*`、 `spring.datasource.oracleucp.*` 的形式指定连接池的配置参数。

如下，是一个指定 Tomcat 数据源连接池的示例：

```properties
spring.datasource.tomcat.max-wait=10000
spring.datasource.tomcat.max-active=50
spring.datasource.tomcat.test-on-borrow=true
```

## 参考资料

- [Spring 官网](https://spring.io/)
- [Spring Framework 官方文档](https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/index.html)
- [Spring Boot 官方文档](https://docs.spring.io/spring-boot/docs/current/reference/html/data.html)
- [数据库连接池学习笔记（一）：原理介绍+常用连接池介绍](https://blog.csdn.net/crankz/article/details/82874158)
- [高性能数据库连接池的内幕](https://mp.weixin.qq.com/s?__biz=MzI3MzEzMDI1OQ==&mid=2651814835&idx=1&sn=cb775d3926ce39d12fa420a292c1f83d&scene=0#wechat_redirect)
